#!/bin/bash

LOG_FILE="${TRIM_TEMP_LOGFILE:-${TRIM_PKGVAR}/info.log}"
PID_FILE="${TRIM_PKGVAR}/app.pid"
MEFRPC_LOG="${TRIM_PKGVAR}/mefrpc.log"
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PKG_DIR="${TRIM_APPDEST:-$(cd "${SCRIPT_DIR}/.." && pwd)}"
MEFRPC_BIN=""
for p in "${PKG_DIR}/www/mefrpc" "${PKG_DIR}/app/www/mefrpc" "${PKG_DIR}/mefrpc" "${PKG_DIR}/target/mefrpc" "${PKG_DIR}/app/mefrpc" "${PKG_DIR}/app/bin/mefrpc" "${SCRIPT_DIR}/../mefrpc"; do
    if [ -f "${p}" ]; then
        MEFRPC_BIN="${p}"
        break
    fi
done
if [ -z "${MEFRPC_BIN}" ]; then
    MEFRPC_BIN="${PKG_DIR}/mefrpc"
fi
MEFRPC_BIND_HOST="${MEFRPC_BIND_HOST:-0.0.0.0}"
MEFRPC_RUN="\"${MEFRPC_BIN}\""
if command -v stdbuf >/dev/null 2>&1; then
    MEFRPC_RUN="stdbuf -oL -eL ${MEFRPC_RUN}"
fi
CMD="cd \"${PKG_DIR}\" && exec ${MEFRPC_RUN} --webui-addr \"${MEFRPC_BIND_HOST}\" >> \"${MEFRPC_LOG}\" 2>&1"

log_msg() {
    echo "$(date '+%Y-%m-%d %H:%M:%S') - $1" >> ${LOG_FILE}
}

start_process() {
    if status; then
        return 0
    fi

    log_msg "Starting process ..."
    log_msg "app: ${TRIM_APPNAME} ver: ${TRIM_APPVER}"
    log_msg "appdir: ${TRIM_APPDEST}"
    log_msg "etc: ${TRIM_PKGETC} var: ${TRIM_PKGVAR} port: ${TRIM_SERVICE_PORT}"
    log_msg "mefrpc log: ${MEFRPC_LOG}"
    log_msg "mefrpc bin: ${MEFRPC_BIN}"
    log_msg "mefrpc bind: ${MEFRPC_BIND_HOST}"
    if [ ! -f "${MEFRPC_BIN}" ]; then
        log_msg "mefrpc not found"
        return 1
    fi
    chmod +x "${MEFRPC_BIN}" >> ${LOG_FILE} 2>&1
    # run cmd to start process
    bash -c "${CMD}" >> ${LOG_FILE} 2>&1 &
    # write pid to pidfile
    local start_pid=$!
    printf "%s" "${start_pid}" > ${PID_FILE}
    sleep 1
    if ! check_process "${start_pid}"; then
        log_msg "process exited immediately, check ${MEFRPC_LOG}"
        return 1
    fi
    # log_msg "CMD = ${CMD}"
    # log_msg "pid = $!"
    return 0
}

stop_process() {
    log_msg "Stopping process ..."

    if [ -r "${PID_FILE}" ]; then
        pid=$(head -n 1 "${PID_FILE}" | tr -d '[:space:]')
        
        log_msg "pid=${pid}"
        if ! check_process "${pid}"; then
            rm -f "${PID_FILE}"
            log_msg "remove pid file 1"
        else
            log_msg "send TERM signal to PID:${pid}..."
            kill -TERM ${pid} >> ${LOG_FILE} 2>&1

            local count=0
            while check_process "${pid}" && [ $count -lt 10 ]; do
                sleep 1
                count=$((count + 1))
                log_msg "waiting process terminal... (${count}s/10s)"
            done

            if check_process "${pid}"; then
                log_msg "send KILL signal to PID:${pid}..."
                kill -KILL "${pid}" >> ${LOG_FILE} 2>&1
                sleep 1
                rm -f "${PID_FILE}"
            else
                log_msg "process killed... "
            fi
        fi
    fi

    if [ -n "${MEFRPC_BIN}" ]; then
        pkill -f "${MEFRPC_BIN}" >> ${LOG_FILE} 2>&1
    fi
    if [ -n "${TRIM_SERVICE_PORT}" ]; then
        pkill -f "mefrpc.*${TRIM_SERVICE_PORT}" >> ${LOG_FILE} 2>&1
    else
        pkill -f "mefrpc" >> ${LOG_FILE} 2>&1
    fi

    return 0
}

check_process() {
    local pid=$1
    if kill -0 "${pid}" 2>/dev/null; then
        return 0  # process exist
    else
        return 1  # process not exist
    fi
}

status() {
    if [ -f "${PID_FILE}" ]; then
        pid=$(head -n 1 "${PID_FILE}" | tr -d '[:space:]')
        if check_process "${pid}"; then
            return 0
        else
            # Process is not running but pidfile exists - clean it up
            rm -f "${PID_FILE}"
        fi    
    fi

    return 1
}

case $1 in
start)
    # run start command. exit 0 if success, exit 1 if failed
    start_process
    ;;
stop)
    # run stop command. exit 0 if success, exit 1 if failed
    stop_process
    ;;
status)
    # check application status command. exit 0 if running, exit 3 if not running
    if status; then 
        exit 0
    else 
        exit 3
    fi
    ;;
*)
    exit 1
    ;;
esac
